#!/bin/sh
#
# generate ASCII output of the RPKI
# Job Snijders <job@openbsd.org>
# November 2020

set -e

PJOBS=16

export LC_ALL=C

if [[ $# -eq 0 ]] ; then
    echo 'must specify output directory'
    exit 1
fi

rm -rf $1/ mapping.txt tal-mapping.txt
mkdir $1/
cp rpki_console.gif $1/

# make 256 subdirectories, so we dont end up
# with 100K files in the output directory
# trashing the performance of the filesystem
for i in 0 1 2 3 4 5 6 7 8 9 A B C D E F; do
	for j in 0 1 2 3 4 5 6 7 8 9 A B C D E F; do
		mkdir $1/${i}${j}; done; done

# run rpki-client to contact all RPKI publication points
# and validate all X509 certificates, produce JSON/CSV output.
# this process also cleans out any invalid certificates from
# the /var/cache/rpki-client/ binary x509 certificate cache
RUN=$(/usr/bin/time rpki-client -vjco 2>&1 >/dev/zero)

# first we hook up the /etc/rpki/*.tal files to index.html
# step one is to extract the URI of the RPKI Root certificate
# with 'test-tal -v', then use 'test-cert -v' pointed to the
# locally cached certificate file to extract the SKI.
# rpki-client earlier on downloaded all files from the rsync
# servers, so all URIs in the rpki output are also locally
# in /var/cache/rpki-client
# rsync://rpki.afrinic.net/repository/AfriNIC.cer is
# also on disk as /var/cache/rpki-client/rpki.afrinic.net/repository/AfriNIC.cer
for i in /etc/rpki/*.tal; do
	TA=$(test-cert -vt $(test-tal -v $i | grep 'URI: rsync' | awk -F// '{ print "/var/cache/rpki-client/" $2 }' ) $i | sed 's/OK//')
	SKI=$(echo "${TA}" | fgrep -m1 'Subject key identifier:' | sed 's/.*: //' | tr '[:lower:]' '[:upper:]')
	MFT=$(echo "${TA}" | fgrep -m1 'Manifest:' | awk -F// '{ print $2 }')
	echo "<a href=\"./$SKI.html\">$SKI</a> $i" >> tal-mapping.txt
cat << EOF > $1/${SKI%${SKI#??}}/${SKI}.html
<a href="./roas.html"><img border=0 src="rpki_console.gif" /></a>
<pre>
<strong>RPKI Root Certificate</strong>
Locator: $i

${TA}

$(openssl x509 -text -inform DER -in $(test-tal -v $i | grep 'URI: rsync' | awk -F// '{ print "/var/cache/rpki-client/" $2 }'))
</pre>
<i>Generated on $(date) by <a href="https://www.rpki-client.org/">rpki-client</a>.</i>
EOF
echo -n T
done

# make the http://console.rpki-client.org/ frontpage
cat << EOF > $1/index.html
<a href="./roas.html"><img border=0 src="rpki_console.gif" /></a>
<pre>
Listing of all current RPKI ROAs: <a href="./roas.html">here</a>.

Trust Anchors:
$(cat tal-mapping.txt | sort -k2)

$ date
$(date)
$ time doas rpki-client -vjc
${RUN}
</pre>
Download the RPKI VRPs in <a href="./vrps.csv">csv</a> or <a href="./vrps.json">json</a> format.<br />
Generated by <a href="https://www.rpki-client.org/">rpki-client</a>.
EOF

cp /var/db/rpki-client/csv $1/vrps.csv
cp /var/db/rpki-client/json $1/vrps.json

# make a header for the big http://console.rpki-client.org/roas.html page
cat << EOF > $1/roas.html
<a href="./"><img border=0 src="rpki_console.gif" /></a>
<style>
td {
  border-bottom: 1px solid grey;
}
</style>
<table>
<tr>
<th>SKI</th>
<th style="width: 20%;">asID</th>
<th>Prefixes</th>
</tr>
EOF

# Start processing ROAs
# here we iterate through each .roa file in the cache
# and then execute the 'test-roa -v' command to extract
# the human readable info about the ROA eContent
# we first spit something out into the big roas.html file
# and then make a per-ROA specific html page with the
# full 'openssl x509' output
cd /var/cache/rpki-client/
for i in $(find * -type f -name '*.roa' -print); do
	if test "$(jobs | wc -l)" -ge $PJOBS; then
		wait
	fi
	{
	ROA=$(test-roa -v ${i} | sed 's/OK//')
	SKI=$(echo "${ROA}" | fgrep -m1 'Subject key identifier:' | sed 's/.*: //' | tr '[:lower:]' '[:upper:]')
	AKI=$(echo "${ROA}" | fgrep -m1 'Authority key identifier:' | sed 's/.*: //')
	ASID=$(echo "${ROA}" | fgrep -m1 'asID:' | awk '{ print $NF }')
	echo "$SKI $(sha256 -qb $i) $(basename $i) $i" >> $1/../mapping.txt
	cat << EOF >> $1/roas.html
<tr>
<td valign="top"><pre><a href="./${SKI}.html">${SKI}</a></pre></td>
<td valign="top" style="text-align:center;"><pre>AS${ASID}</pre></td>
<td>
<pre>
$(echo "${ROA}" | fgrep 'max: ')
</pre>
</td>
</tr>
EOF
	# now make the detailed page about the .roa file
	cat << EOF | sed "s|${AKI}|<a href=\"./${AKI}.html\">${AKI}\</a\>|" > $1/${SKI%${SKI#??}}/${SKI}.html
<img src="rpki_console.gif" />
<pre>
<strong>Route Origin Authorization</strong>
Location: <strong>${i}</strong>

${ROA}

$(test-roa -p ${i} | openssl x509 -text)
</pre>

<i>Generated on $(date) by <a href="https://www.rpki-client.org/">rpki-client</a>.</i>
EOF
echo -n R
} &
done

echo "</table><i>Generated on $(date) by <a href="https://www.rpki-client.org/">rpki-client</a>.</i>" >> $1/roas.html

# Start processing manifests, quite similar to .roa files
cd /var/cache/rpki-client/
for i in $(find * -type f -name '*.mft' -print); do
	if test "$(jobs | wc -l)" -ge $PJOBS; then
		wait
	fi
	{
	MFT=$(test-mft -v ${i} | sed 's/OK//')
	SKI=$(echo "${MFT}" | fgrep -m1 'Subject key identifier:' | sed 's/.*: //' | tr '[:lower:]' '[:upper:]')
	AKI=$(echo "${MFT}" | fgrep -m1 'Authority key identifier:' | sed 's/.*: //')
	echo "$SKI $(sha256 -qb $i) $(basename $i) $i" >> $1/../mapping.txt
	cat << EOF | sed "s|${AKI}|<a href=\"./${AKI}.html\">${AKI}\</a\>|" > $1/${SKI%${SKI#??}}/${SKI}.html
<img src="rpki_console.gif" />
<pre>
<strong>RPKI Manifest</strong>
Location: <strong>${i}</strong>

${MFT}

$(test-mft -p ${i} | openssl x509 -text)
</pre>

<i>Generated on $(date) by <a href="https://www.rpki-client.org/">rpki-client</a>.</i>
EOF
echo -n M
} &
done
wait

# certificates, here we don't need a separate '-p' pass as the .cer
# files are simpler BER/DER formatted files.
cd /var/cache/rpki-client/
for i in $(find * -type f -name '*.cer' -print); do
	if test "$(jobs | wc -l)" -ge $PJOBS; then
		wait
	fi
	{
	CERT=$(test-cert -v ${i} 2>/dev/zero | sed 's/OK//')
	if [ "$CERT" = "" ]; then
		echo -n .
	else
		SKI=$(echo "${CERT}" | fgrep -m1 'Subject key identifier:' | sed 's/.*: //' | tr '[:lower:]' '[:upper:]')
		AKI=$(echo "${CERT}" | fgrep -m1 'Authority key identifier:' | sed 's/.*: //')
		echo "$SKI $(sha256 -qb $i) $(basename $i) $i" >> $1/../mapping.txt
		cat << EOF | sed "s|${AKI}|<a href=\"./${AKI}.html\">${AKI}\</a\>|" > $1/${SKI%${SKI#??}}/${SKI}.html
<img src="rpki_console.gif" />
<pre>
<strong>RPKI Certificate</strong>
Location: <strong>${i}</strong>

${CERT}

$(openssl x509 -text -inform DER -in ${i})
</pre>

<i>Generated on $(date) by <a href="https://www.rpki-client.org/">rpki-client</a>.</i>
EOF
		echo -n C
	fi
	} &
done
wait

# now, at this point the mappings.txt file is very very big but contains
# all information to hook up all interesting urls and identifiers up to
# each other in a logical way.
# link all keywords
cd $1/
for SKIFILE in $(find . -name "*.html" -print); do
	if test "$(jobs | wc -l)" -ge $PJOBS; then
		wait
	fi
	{
	for LINK in $(egrep '[[:space:]]hash |URI:rsync://' ${SKIFILE} | fgrep -v '.crl' | awk '{ print $NF }' | sed 's/URI:rsync:\/\///'); do
		fgrep " $LINK" ../mapping.txt | while IFS=' ' read -r MSKI MHASH MRFP MLFP; do
			perl -p -i -e "s|\Q$MHASH\E|\<a href=\"./${MSKI}.html\">$MHASH\</a\>|;" \
				-e "s|\Q: $MRFP\E|: \<a href=\"./${MSKI}.html\">$MRFP\</a\>|;" \
				-e "s|\Qrsync://$MLFP\E|rsync://<a href=\"./${MSKI}.html\">$MLFP\</a\>|" ${SKIFILE}
		done
	done
	echo -n L
} &
done
wait
echo
find . -name "*.html" -print | xargs -J % mv % .
find . -type d ! -path . | xargs rmdir
